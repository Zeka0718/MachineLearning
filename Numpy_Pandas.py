import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# numpy的属性：维度ndim，行列数shape，元素个数size
a = np.array([[1,2,3],[4,5,6]])
print("ndim:" + str(a.ndim))
print("shape:"+str(a.shape))
print("size:"+str(a.size))
print()
print("******************************")
print()

# numpy的几种创建方法，包括ones，zeros，empty，arange，使用reshape改变形状，使用flatten拍扁
b = np.empty((3,4),dtype=np.float32)
c = np.arange(0,12,1)
d = np.reshape(c,(3,4),order=0)
e = d.flatten(order=1)
print("b:",b)
print("c:",c)
print("d:",d)
print("e:",e)
print()
print("******************************")
print()

# numpy的基本运算
a = np.array([[1,2],[3,4]])
b = np.array([[1,2],[3,4]])
print("a*b即元素相乘:")
print(a*b)
print("np.dot(a,b)即矩阵的乘法:")
print(np.dot(a,b))
print()
print("******************************")
print()

# numpy的基础函数mean，media，cumsum，diff，nonzero，clip，argmin，argmax
a = np.array([[1,2,3,4],[5,6,7,8],[9,10,11,12]])
print("cumsum就是生成的每一项矩阵元素均是从原矩阵首项累加到对应项的元素之和")
print(np.cumsum(a))
print("diff是累差运算函数")
print(np.diff(a))
print("nonzero将所有非零元素的行与列坐标分割开，重构成两个分别关于行和列的矩阵。")
print(np.nonzero(a))
print("clip用于让函数判断矩阵中元素是否有比最小值小的或者比最大值大的元素，并将这些指定的元素转换为最小值或者最大值")
print(np.clip(a,3,10))
print("argmin和argmax分别找出元素中最大值和最小值的索引，axis参数可以设置0为列，1为行")
print(np.argmax(a,axis=0))
print(np.argmin(a))
print()
print("******************************")
print()

# numpy的合并函数vstack，hstack，增加维度操作newaxis，分割操作split
a = np.array([1,2,3])
b = np.array([4,5,6])
c = np.array([[1,2,3,4],[5,6,7,8]])
print("vstack:")
print(np.vstack((a,b)))
print("hstack:")
print(np.hstack((a,b)))
print("newaxis operation:")
print("a.shape:",a.shape)
print("after newaxis:",a[np.newaxis].shape)
print("split:")
print(np.split(c,2,axis=1))
print("此外应该注意python中的数据结构，深复制问题")
e = a.copy()
a[0]=4
print(e)
print()
print("******************************")
print()

# Pandas中的Series和DataFrame
s = pd.Series([1,2,3,np.nan,5])
print(s)
print("pd中的DataFrame内容实际上是np.array，再加上index名称和columns名称")
p = pd.DataFrame([[1,2,3.0,4],[5,6,7.0,8],[5,1,4.0,2]],index=['a','b','c'],columns=['A','B','C','D'])
print(p)
print()
print("******************************")
print()

# Pandas中DataFrame的一些属性,包括dtype，columns，index，values, describe，sort_index，sort_values
print("dtype:")
print(p.dtypes)
print("columns:")
print(p.columns)
print("index:")
print(p.index)
print("values,即返回一个np.array")
print(p.values)
print(type(p.values))
print("describe:")
print(p.describe())
print("原始数据")
print(p)
print("按照表头进行排序后输出，0对行表头排序，1对列表头排序")
print(p.sort_index(axis=0,ascending=0))
print("按照某一列的值排序，类似excel列排序")
print(p.sort_values('B',ascending=0))
print()
print("******************************")
print()


# 选择数据, loc属性选择多行多列（根据标签选择），iloc属性选择特定位置（更具位置选择），ix属性，综合上述两者, 以及选择性筛选
p = pd.DataFrame(np.arange(16).reshape(4,4),index=['a','b','c','d'],columns=['A','B','C','D'])
print("原始数据")
print(p)
print("选择某一列")
print(p['A'])
print("切片")
print(p[0:2])
print("pandas属性loc选择多行多列,注意列可以忽略，但是行一定要有")
print(p.loc[['a','c']])
print(p.loc[['a','c','d'],['A','C']])
print("pandas属性iloc选择具体位置,注意列可以忽略，但是行一定要有")
print(p.iloc[[0,2]])
print(p.iloc[[0,2],[1,3]])
print("pandas属性ix选择具体位置,注意列可以忽略，但是行一定要有")
print(p.ix[[0,2],['A','C']])
print("选择性筛选例子，注意这里使用按位与")
print(p[(p.A>5) & (p.B>10)])
print("增加多一列F")
p['F']=np.NAN
print(p)
print()
print("******************************")
print()

# 处理空值，dropna，fillna，isnull
p['F']=1.0
p.loc['a','B'] = np.NAN
p.loc['b','C'] = np.NAN
print(p)
print("dropan可以删掉值为NAN的行或者列，any表示一旦有NAN就删除，all表示全部是NAN才删除")
print(p.dropna(axis=0,how='any'))
print("fillna可以填充NAN的位置")
print(p.fillna(value='h'))
print("isnull可以输出一个与原来数组一样大小的TF数组，如果担心看不完，可以与np.any组合")
print(p.isnull())
print(np.any(p.isnull())==True)
print()
print("******************************")
print()

# pandas合并concat，join参数可以处理不一样的列，join_axes=[df1.index](按照df1中的index作为基准合并)，append
a = pd.DataFrame(0*np.arange(16).reshape(4,4),index=['a','b','c','d'],columns=['A','B','C','D'])
b = pd.DataFrame(1*np.arange(16).reshape(4,4),index=['a','b','c','d'],columns=['A','B','C','D'])
c = pd.DataFrame(2*np.arange(16).reshape(4,4),index=['a','b','c','d'],columns=['A','B','C','D'])
d = pd.DataFrame(2*np.arange(16).reshape(4,4),index=['a','b','c','d'],columns=['B','C','D','E'])
print(a)
print(b)
print(c)
print("axis决定合并方向，ignore_index重新分配index")
print(pd.concat([a,b,c],axis=1,ignore_index=True))
print("join参数可以处理不一样的参数，默认outer")
print(pd.concat([a,d],axis=0,join='inner'))
print("append即在表的尾部纵向增加数据")
print(a.append([b,c],ignore_index=True))

# pandas高级合并操作,on = key指定按照那一列进行对照合并，indicator=True会将合并的记录放在新的一列，index可以设置按照index合并
# 而suffixes参数则可以用来修改合并后同名的列名
a = pd.DataFrame([[1,2,'s','y'],[3,4,'a','n'],[4,5,'t','y']],columns=['A','B','key','key2'])
b = pd.DataFrame([[0,0,'a','n'],[3,4,'s','n'],[4,5,'t','n']],columns=['a','B','key','key2'])
print("根据key进行合并操作")
print(pd.merge(a,b,on='key'))
print("根据两个key合并，方式有left，right，outer，inner，其中left和right分别按照左边或者右边作为标准")
print(pd.merge(a,b,on=['key','key2'],how='outer', indicator='indicator_column'))
print("根据index合并")
print(pd.merge(a,b,left_index=True,right_index=True,how='outer', indicator='indicator_column'))
print("合并后修改同名列的名字使用suffixes参数")
print(pd.merge(a,b,on=['key','key2'],how='outer', indicator='indicator_column',suffixes=['_1','_2']))
print()
print("******************************")
print()

# 简单可视化工具
data = pd.Series(np.random.randn(1000),index=np.arange(1000))
df = pd.DataFrame(np.random.randn(1000,3),index=np.arange(1000),columns=['A','B','C'])
data = data.cumsum()
df = df.cumsum()
data.plot(color='lightgreen')
df.plot()
print("使用scatter制作散点图")
ax = df.plot.scatter(x='A',y='B',color='lightblue',label='c1')
bx = df.plot.scatter(x='A',y='C',color='pink',label='c2',ax=ax)
df.plot.scatter(x='B',y='C',color='green',label='c2',ax=bx)
plt.show()